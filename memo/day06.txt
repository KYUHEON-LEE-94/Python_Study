day06
과제풀이 -> 복습 -> 리스트 -> 튜플 -> 세트 -> 딕셔너리 -> 함수

5일차 과제풀이
https://colab.research.google.com/drive/1Gkv184oRkSyK96WioAztvEOFZ6m-oiL_?usp=sharing

6일차 수업예제
https://colab.research.google.com/drive/1pcgTdq1yvsShWlt8-DBNUBicsuRsr83i?usp=sharing


0. 복습
	1) while문	: 특정조건을 만족하는 동안 반복해서 수행
	2) for문 : 범위나 횟수가 정해져있는 동안 반복해서 수행
	3) range() : for문과 같이 사용
		(종료값), (시작값, 종료값), (시작값, 종료값, 스텝값)
	4) 기타제어문
	   - break문 : 감싸고 있는 반복문 탈출, 강제종료할 때 사용
	   - continue문 : 다음 반복으로 넘어간다(아래쪽에 있는 문장은 스킵)
	   - pass문 : 오류를 발생시키지 않기 위해서 사용하는 경우가 많음
		   아무런 처리를 하지 않기 때문에 다음 처리를 계속 진행함

1. 컬렉션 => 리스트, 튜플, 세트, 딕셔너리
1) 함수와 메소드
	함수 -> 함수명()
	(ex) print(), input(), int(), str() 등..
	어떤 기능을 한다
	독립적으로 사용가능

	메소드(메서드) -> 객체.메소드명()
	메소드는 어떠한 객체와 항상 연관이 있다. => 변수는 모두 객체(object)
	사용하고자하는 대상이 .으로 연결이 되어있어야함
	(ex) list = [1, 2, 3, 4]
	list.append(5) => [1, 2, 3, 4, 5] , list.insert(3, 5) => [1, 2, 3, 5, 4]

 함수와 메소드의 차이 => 특정 객체를 통해서 호출하는지 여부로 판단
			특정 객체로 호출한다 => 메소드
			독립적으로 호출한다 => 함수

1. 리스트(list)
	[], 순서가 존재함(인덱스 번호를 사용)
	중복도 허용
	값의 수정, 삭제도 가능

리스트 생성
	(변수 생성) 변수명 = 값
	리스트명 = [값1, 값2, 값3, [값4, 값5], [값6, 값7, 값8]]

리스트 요소에 접근하기
	인덱스연산자 []와 인덱스 번호를 활용
	리스트명[인덱스 번호]
	* 인덱스번호 0부터 시작, 마이너스는 뒤에서 -1부터 시작
	
인덱스 슬라이싱
	인덱스 번호를 활용해서 슬라이싱 하는 행위
	리스트명[idx1: idx2]
	리스트명[:idx1]	=> 처음부터 해당종료 인덱스 번호까지 잘라줌
	리스트명[idx1:]	=> 해당시작 인덱스번호부터 끝까지 잘라줌

리스트의 요소값 수정하기
	대입연산자(=)가 사용되면 저장공간으로 활용됨
	리스트명[idx] = 변경할 값

리스트와 관련된 메소드
	어떤 리스트에 적용시킬 것인지 소속을 알려줘야함
	리스트명.메소드명()

	.append(값)	: 값을 맨 뒤의 리스트에 추가 해준다
	.insert(idx, 값)	: 값을 해당 idx에 추가해준다
	.remove(값)	: 값을 삭제한다 #값이 없을 때 오류가 발생
	.pop(idx)		: 해당 인덱스의 요소를 삭제한다
	.sort()		: 요소를 오름차순 정렬해준다 #같은 자료형일 때만 가능
	.sort(reverse = True) : 요소를 내림차순 정렬해준다
	.extend		: 리스트와 다른 리스트를 연결해준다 ( + 연산자와 다르다(구분필요!))

비어있는 리스트 만들기
	리스트명 = []
	리스트명 = list()

len()
	리스트의 길이(요소의 갯수) 알려줌

시퀀스 멤버 조회
	조회할 원소 in 시퀀스
	* 시퀀스 자료형 => 리스트, 문자열, 튜플
	* 비시퀀스 자료형 => 세트, 딕셔너리

2) 튜플(Tuple)
	순서가 존재함(인덱스 번호를 사용할 수 있음)
	중복을 허용함
	값의 추가나 수정이 불가능 => 읽기전용 리스트

튜플의 생성
	리스트명 = [값1,...]
	튜플명 = (값1, 값2, ...)
		(값1, )	값이 1개만 입력시 값 뒤에 콤마(,)를 반드시 붙여줘야함!!!
			,를 붙이는 이유는 소괄호가 최우선 연산자가 아님을 알려주기 위해서 사용함

비어있는 튜플의 생성
	튜플명 = ()
	튜플명 = tuple()

튜플의 메소드
	.count(값)		: 해당 값이 몇개인지 알려줌
	.index(값)		: 해당값의 인덱스 번호를 알려줌
			값의 중복이 있다면 맨 앞의 요소 인덱스 번호를 알려줌
			tuple1 = (1, 2, 3, 4, 1, 1, 2, 4)
			tuple1.index(1) ==> 결과는 tuple1[0]

튜플의 연산
	tuple + tuple => tuple 연결
	tuple * int => tuple 반복

튜플의 소괄호는 생략이 가능함
여러개의 변수를 튜플을 통해서 동시 생성할 수 있음

3) 세트(set)
	{}
	순서가 없음(인덱스 번호를 사용할 수 없음)
	중복된 값도 허용하지 않음
	수정은 가능함

세트의 생성
	세트명 = {값1, 값2, ...}

비어있는 세트의 생성
	세트명 = {}
	세트명 = set()

세트와 관련된 메소드
	.add(값) 	: 값을 추가한다. 중복된 값을 추가가 되지 않음
	.remove(값) : 값을 삭제한다. 없는 요소를 삭제하려고 하면 오류가 발생
	.discard(값) : 값을 삭제한다. 없는 요소를 삭제하려고 하면 오류가 발생하지 않음
	.pop()	: 요소 한개를 삭제한다. 인덱스로는 사용 불가, ()로 작성하면 맨 뒤에 있는 요소가 삭제됨

세트에서 요소 가져오기
	1) 형변환(list, tuple)
	2) 바뀐 컬렉션에서 index 가져오기

교집합	> 공통된 부분
	세트1 & 세트2	
합집합	> 더해짐
	세트1  |  세트2
차집합	> 빠짐
	세트1  -  세트2

















